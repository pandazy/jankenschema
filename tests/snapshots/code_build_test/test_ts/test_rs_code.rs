
/**
 * This file was generated by the extract tool.
 * Do not modify this file manually.
 * Unless you know what you are doing or at your own risk
 */

use serde_json::{json, Value, to_value};

///
/// The struct of the RsTestTable
/// based on the database table rs_test_table
///
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RsTestTable {
	id: isize,
	name: String,
	age: Option<isize>,
	cash: Option<f64>,
	dep: Option<String>
}

///
/// The source-of-truth resource name (database table name) of the RsTestTable
///
pub const RESOURCE_NAME: &str = "rs_test_table";

///
/// The data column names of the RsTestTable
///
pub const FIELD_NAMES: [&str; 5] = ["id", "name", "age", "cash", "dep"];

pub const COL_NAME_ID: &str = "id";
pub const COL_NAME_NAME: &str = "name";
pub const COL_NAME_AGE: &str = "age";
pub const COL_NAME_CASH: &str = "cash";
pub const COL_NAME_DEP: &str = "dep";

///
/// The data column set of the RsTestTable
///
pub fn field_name_set() -> std::collections::HashSet<String> {
    FIELD_NAMES.iter().map(|s| s.to_string()).collect()
}


///
/// Verify the input for the RsTestTable operation, make sure it's a valid payload
///
pub fn verify_common(input: &Value) -> anyhow::Result<()> {
    let name_set = field_name_set();
    if !input.is_object() {
        return Err(anyhow::anyhow!(
            "The input for the operation of RsTestTable must be a json object"
        ));
    }
    let input_map = input.as_object().unwrap();
    if input_map.keys().len() == 0 {
        return Err(anyhow::anyhow!(
            "The input for the operation of RsTestTable doesn't have any key"
        ));
    }
    let trespasser_option = input_map
        .keys()
        .find(|key| !name_set.contains(&key.to_string()));
    if let Some(trespasser) = trespasser_option {
        return Err(anyhow::anyhow!(
            "The input for the operation of RsTestTable has a key '{}' that is not allowed",
            trespasser
        ));
    }
    Ok(())
}

///
/// Verify the presence of required fields of the input for the RsTestTable operation
///
pub fn verify_required(input: &Value) -> anyhow::Result<()> {
    verify_common(input)?;
    let input_map = input.as_object().unwrap();
	if input_map.get("id").is_none() { return Err(anyhow::anyhow!("The input for the operation of RsTestTable requires the value of 'id'"));}
	if input_map.get("name").is_none() { return Err(anyhow::anyhow!("The input for the operation of RsTestTable requires the value of 'name'"));}
    Ok(())
}

///
/// Get the default values for the RsTestTable's payload
///
pub fn get_defaults() -> Value {
	let val_age = 9;
	let val_cash = 4.2;
	let val_dep = r#"dev-"big"'BIG'"#;
    json!({
	"age": val_age,
	"cash": val_cash,
	"dep": val_dep,
    })
}

///
/// Get a combined payload with the given input, fill the missing fields with default values
///
pub fn defaults_if_absent(input: &Value) -> anyhow::Result<Value> {
    verify_common(input)?;
    let input_map = input.as_object().unwrap();
    let defaults = get_defaults();
    let ret = defaults.as_object().unwrap().iter().chain(input_map)
        .map(|item| (item.0.to_string(), item.1.clone()))
        .collect::<std::collections::HashMap<String, Value>>();
    Ok(to_value(ret)?)
}
